<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÁÜäÁÜäÊ∂àÊ∂à‰πê - ‰ºòÂåñÁâà</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/mitt@3/dist/mitt.umd.js"></script>
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --board-size: min(90vw, 400px);
            --tile-size: calc(var(--board-size) / 8 - 2px);
            --control-height: 60px;
            --border-radius: 15px;
            --spacing-sm: 8px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-gradient);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: padding 0.3s ease;
        }

        .game-container {
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
            margin: 10px;
            max-width: min(95vw, 500px);
            max-height: min(95vh, 700px);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: white;
            padding: 30px;
            border-radius: var(--border-radius);
            text-align: center;
            max-width: 350px;
            width: 90%;
        }

        .start-btn, .action-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .start-btn:hover, .action-btn:hover {
            transform: scale(1.05);
        }

        .top-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: var(--control-height);
            background: var(--primary-gradient);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            z-index: 100;
        }

        .right-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .bgm-selector {
            position: static;
            background: none;
            border-radius: 0;
            padding: 0;
            display: flex;
            gap: 5px;
        }

        .bgm-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        .bgm-btn.active {
            background: rgba(255,255,255,0.8);
            color: #333;
        }

        .audio-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            touch-action: manipulation;
            min-width: 32px;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            touch-action: manipulation;
        }

        .action-btn.green {
            background: #27ae60;
        }

        .action-btn.green:hover {
            background: #229954;
        }

        .score-info {
            background: var(--primary-gradient);
            color: white;
            padding: 15px;
            margin: calc(-1 * var(--control-height)) -20px 20px -20px;
            padding-top: calc(var(--control-height) + 15px);
            border-radius: 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .score-box {
            text-align: center;
        }

        .score-label {
            display: block;
            font-size: 12px;
            opacity: 0.8;
        }

        .score-value {
            display: block;
            font-size: 18px;
            font-weight: bold;
        }

        .game-content {
            padding: calc(var(--control-height) + 10px) 20px 20px 20px;
        }

        .game-board-container {
            position: relative;
        }

        .game-board {
            width: var(--board-size);
            height: var(--board-size);
            max-width: 400px;
            max-height: 400px;
            margin: 0 auto;
            display: grid;
            gap: 2px;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 10px;
            position: relative;
        }

        .game-tile {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            touch-action: manipulation;
            font-size: 24px;
            font-weight: bold;
        }

        .game-tile img {
            width: 85%;
            height: 85%;
            object-fit: contain;
            pointer-events: none;
        }

        .game-tile:hover {
            transform: scale(1.05);
        }

        .game-tile.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            border: 3px solid gold;
        }

        .game-tile.matched {
            animation: matchPulse 0.3s ease;
        }

        .game-tile.shake {
            animation: shake 0.4s ease;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            animation: fadeInOut 1.2s ease;
        }

        .message-box.error { background: rgba(255, 107, 107, 0.9); }
        .message-box.success { background: rgba(67, 233, 123, 0.9); }
        .message-box.chain { background: rgba(255, 215, 0, 0.9); color: #333; }

        .chain-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            pointer-events: none;
        }

        .chain-text {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: chainPulse 1s ease-out;
        }

        @keyframes chainPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        .particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 90;
        }

        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--primary-gradient);
            display: flex; justify-content: center; align-items: center;
            z-index: 9999;
        }

        .loading-content { text-align: center; color: white; max-width: 400px; padding: 40px; }
        .loading-spinner {
            width: 60px; height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .loading-progress { margin: 30px 0; }
        .progress-bar { width: 100%; height: 8px; background: rgba(255, 255, 255, 0.3); border-radius: 4px; overflow: hidden; margin-bottom: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 4px; transition: width 0.3s ease; }
        .progress-text { font-size: 18px; font-weight: bold; }
        .loading-tips { margin-top: 20px; font-size: 14px; opacity: 0.9; }
        .loading-error { margin-top: 20px; color: #ff6b6b; font-weight: bold; }
        .retry-btn { margin-top: 15px; padding: 10px 20px; border-radius: 8px; border: none; background: white; color: #333; cursor: pointer; }

        .settings-btn {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none; padding: 10px 15px; border-radius: 8px;
            cursor: pointer; font-size: 14px; transition: all 0.3s ease;
            z-index: 1001;
        }

        .settings-btn:hover { background: white; transform: translateY(-2px); }

        .settings-panel {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 2000;
        }

        .settings-content {
            background: white; padding: 30px; border-radius: var(--border-radius);
            max-width: 400px; width: 90%; max-height: 80vh; overflow-y: auto;
        }

        .settings-content h3 { margin: 0 0 20px 0; text-align: center; color: #333; }
        .setting-group { margin-bottom: 20px; }
        .setting-group label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        .setting-group input[type="range"] { width: 70%; margin-right: 10px; }
        .setting-group select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px; }
        .settings-actions { display: flex; gap: 10px; margin-top: 25px; }
        .settings-actions button { flex: 1; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; }
        .reset-btn { background: #ff6b6b; color: white; }
        .close-btn { background: #4ecdc4; color: white; }
        .settings-actions button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }

        .tile-type-1 { background: linear-gradient(135deg, #8B4513, #A0522D); color: white; }
        .tile-type-2 { background: linear-gradient(135deg, #FFB6C1, #FFC0CB); color: #8B4513; }
        .tile-type-3 { background: linear-gradient(135deg, #FF8C00, #FFA500); color: white; }
        .tile-type-4 { background: linear-gradient(135deg, #8B4513, #D2691E); color: white; }
        .tile-type-5 { background: linear-gradient(135deg, #32CD32, #90EE90); color: #006400; }
        .tile-type-6 { background: linear-gradient(135deg, #000000, #696969); color: white; }

        @keyframes matchPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); background: #ffd700; }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @media (min-width: 768px) {
            :root {
                --control-height: 70px;
                --board-size: 450px;
            }
            body { padding: 20px; }
            .game-container { max-width: 600px; max-height: 800px; margin: 0 auto; }
            .top-controls { padding: 15px 20px; }
            .bgm-btn { padding: 8px 14px; font-size: 13px; }
            .audio-btn { min-width: 40px; min-height: 40px; font-size: 16px; }
            .game-content { padding: calc(var(--control-height) + 20px) 30px 30px 30px; }
        }

        @media (min-width: 1200px) {
            :root {
                --board-size: 500px;
            }
            .game-container { max-width: 700px; max-height: 900px; }
        }

        @media (max-width: 480px) {
            :root {
                --control-height: 50px;
                --board-size: min(85vw, 350px);
            }
            body { padding: 5px; }
            .game-container { margin: 5px; border-radius: 15px; max-width: 98vw; max-height: 98vh; }
            .top-controls { padding: 8px 12px; }
            .bgm-btn { padding: 5px 8px; font-size: 10px; }
            .audio-btn { min-width: 28px; min-height: 28px; font-size: 12px; padding: 6px; }
            .pause-btn { padding: 6px 10px; font-size: 11px; }
            .game-content { padding: calc(var(--control-height) + 5px) 15px 15px 15px; }
        }

        @media (max-width: 360px) {
            :root {
                --board-size: min(80vw, 300px);
            }
            .bgm-btn { padding: 4px 6px; font-size: 9px; }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            body { align-items: flex-start; padding-top: 10px; }
            .game-container { max-height: 95vh; }
            :root {
                --board-size: min(40vh, 350px);
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="showLoading" class="loading-overlay">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <h2>üéÆ Ê∏∏ÊàèÂä†ËΩΩ‰∏≠...</h2>
                <div class="loading-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" :style="{ width: loadingProgress + '%' }"></div>
                    </div>
                    <div class="progress-text">{{ Math.round(loadingProgress) }}%</div>
                </div>
                <div class="loading-tips">
                    <p v-if="loadingProgress < 20">Ê≠£Âú®ËøûÊé•ËµÑÊ∫êÊúçÂä°Âô®...</p>
                    <p v-else-if="loadingProgress < 95">Ê≠£Âú®Âä†ËΩΩÊ∏∏ÊàèËµÑÊ∫ê...</p>
                    <p v-else>Âç≥Â∞ÜÂÆåÊàê...</p>
                </div>
                <div v-if="loadingError" class="loading-error">
                    {{ loadingError }}
                    <button class="retry-btn" @click="retryLoading">ÈáçÊñ∞Âä†ËΩΩ</button>
                </div>
            </div>
        </div>
        <button v-if="!showLoading" @click="openSettings" class="settings-btn">
            ‚öôÔ∏è ËÆæÁΩÆ
        </button>
        <div v-if="showSettings" class="settings-panel">
            <div class="settings-content">
                <h3>üéÆ Ê∏∏ÊàèËÆæÁΩÆ</h3>
                <div class="setting-group">
                    <label>üéµ BGMÈü≥Èáè</label>
                    <input type="range" min="0" max="100" v-model="bgmVolume" @input="updateBgmVolume">
                    <span>{{ bgmVolume }}%</span>
                </div>
                <div class="setting-group">
                    <label>üîä Èü≥ÊïàÈü≥Èáè</label>
                    <input type="range" min="0" max="100" v-model="sfxVolumePercent" @input="updateSfxVolume">
                    <span>{{ sfxVolumePercent }}%</span>
                </div>
                <div class="setting-group">
                    <label>üß© Ê£ãÁõòÂ§ßÂ∞è</label>
                    <select v-model="boardSize" @change="handleBoardSizeChange">
                        <option value="6">6x6</option>
                        <option value="8">8x8</option>
                        <option value="10">10x10</option>
                    </select>
                </div>
                <div class="settings-actions">
                    <button @click="resetSettings" class="reset-btn">ÈáçÁΩÆËÆæÁΩÆ</button>
                    <button @click="closeSettings" class="close-btn">ÂÖ≥Èó≠</button>
                </div>
            </div>
        </div>
        <div class="game-container">
             <div v-if="gameStarted" class="top-controls">
                <div class="bgm-selector">
                    <button 
                        v-for="bgm in bgmList" 
                        :key="bgm.id"
                        class="bgm-btn"
                        :class="{ active: currentBgmId === bgm.id }"
                        @click="switchBgm(bgm)"
                    >
                        BGM{{ bgm.id }}
                    </button>
                </div>
                
                <div class="right-controls">
                    <button class="audio-btn" @click="toggleBgm" :title="bgmPlaying ? 'ÊöÇÂÅúÈü≥‰πê' : 'Êí≠ÊîæÈü≥‰πê'">
                        {{ bgmPlaying ? 'üîä' : 'üîá' }}
                    </button>
                    <button class="audio-btn" @click="toggleSfx" :title="sfxEnabled ? 'ÂÖ≥Èó≠Èü≥Êïà' : 'ÂºÄÂêØÈü≥Êïà'">
                        {{ sfxEnabled ? 'üéµ' : 'üîï' }}
                    </button>
                    <button class="pause-btn" @click="togglePause" v-if="!showGameOver">
                        {{ isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è' }}
                    </button>
                </div>
            </div>
            <div v-if="!gameStarted && !showLoading" class="overlay">
                <div class="modal">
                    <h2 style="margin-bottom: 20px; color: #333;">ÁÜäÁÜäÊ∂àÊ∂à‰πê</h2>
                    <button class="start-btn" @click="startGame">ÂºÄÂßãÊ∏∏Êàè</button>
                    <div v-if="isMobile" style="margin-top: 15px; font-size: 14px; color: #666;">
                        ÊèêÁ§∫ÔºöÁÇπÂáªÂ±èÂπïÊéàÊùÉÈü≥È¢ëÊí≠Êîæ
                    </div>
                </div>
            </div>
            <div v-if="showGameOver" class="overlay">
                <div class="modal">
                    <h3 style="margin-bottom: 15px; color: #e74c3c;">Ê∏∏ÊàèÁªìÊùü</h3>
                    <div style="margin-bottom: 20px; color: #666;">
                        <p>ÊúÄÁªàÂàÜÊï∞: {{ score }}</p>
                        <p>‰ΩøÁî®Ê≠•Êï∞: {{ movesUsed }}</p>
                        <p>Ê∏∏ÊàèÊó∂Èïø: {{ formattedTime }}</p>
                    </div>
                    <div class="end-btn-row">
                        <button class="action-btn purple" @click="restartGame">ÈáçÊñ∞ÂºÄÂßã</button>
                    </div>
                </div>
            </div>
            <div v-if="isPaused" class="overlay">
                <div class="modal">
                    <h3 style="margin-bottom: 15px; color: #3498db;">‚è∏Ô∏è Ê∏∏ÊàèÊöÇÂÅú</h3>
                    <div style="margin-bottom: 20px; color: #666;">
                        <p>ÂΩìÂâçÂàÜÊï∞: {{ score }}</p>
                        <p>Â∑≤Áî®Ê≠•Êï∞: {{ movesUsed }}</p>
                        <p>Ê∏∏ÊàèÊó∂Èïø: {{ formattedTime }}</p>
                    </div>
                    <div class="end-btn-row">
                        <button class="action-btn green" @click="togglePause">ÁªßÁª≠Ê∏∏Êàè</button>
                        <button class="action-btn gray" @click="restartGame">ÈáçÊñ∞ÂºÄÂßã</button>
                    </div>
                </div>
            </div>
            <div class="game-content">
                <div class="score-info">
                    <div class="score-box">
                        <span class="score-label">ÂàÜÊï∞</span>
                        <span class="score-value">{{ score }}</span>
                    </div>
                    <div class="score-box">
                        <span class="score-label">Ê≠•Êï∞</span>
                        <span class="score-value">{{ movesUsed }}</span>
                    </div>
                    <div class="score-box">
                        <span class="score-label">Êó∂Èó¥</span>
                        <span class="score-value">{{ formattedTime }}</span>
                    </div>
                </div>
                <div class="game-board-container">
                    <div 
                        class="game-board" 
                        :style="boardStyle"
                        @click="handleOutsideClick"
                    >
                        <div
                            v-for="(tile, index) in flatBoard"
                            :key="tile.id"
                            class="game-tile"
                            :class="getTileClasses(tile)"
                            @click.stop="debouncedTileClick(tile)"
                        >
                            <img v-if="hasImage(tile.type)" :src="getTileImage(tile.type)" :alt="getTileSymbol(tile.type)" @error="handleImageError(tile.type)" />
                            <span v-else>{{ getTileSymbol(tile.type) }}</span>
                        </div>
                    </div>
                    <canvas class="particle-canvas" ref="particleCanvas"></canvas>
                    <div
                        v-if="showMessage"
                        class="message-box"
                        :class="messageType"
                    >
                        {{ message }}
                    </div>
                    <div v-if="showChainEffect" class="chain-effect">
                        <div class="chain-text">ËøûÈîÅ x{{ chainCount }}</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, nextTick, watch } = Vue;
        const emitter = mitt();

        // Èü≥È¢ëÁÆ°ÁêÜÊ®°Âùó
        const useAudioManager = () => {
            const bgmList = ref([
                { id: 1, name: "ËΩªÊùæBGM", src: "" },
                { id: 2, name: "Ê¥ªÊ≥ºBGM", src: "" }
            ]);
            const sfxMap = {
                click: "", swap: "",
                match: "", error: "",
                fall: "", countdown: "",
                win: "", lose: "",
                nomove: ""
            };
            const bgmPlaying = ref(false);
            const sfxEnabled = ref(true);
            const currentBgmId = ref(0);
            const bgmVolume = ref(50);
            const sfxVolumePercent = ref(70);
            const isMobile = ref(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2));
            
            class HybridAudioManager {
                constructor() {
                    this.useWebAudio = false;
                    this.audioContext = null;
                    this.bgmGainNode = null;
                    this.sfxGainNode = null;
                    this.bgmSource = null;
                    this.bgmBuffer = null;
                    this.sfxBuffers = new Map();
                    this.bgmAudio = null;
                    this.sfxAudioPool = new Map();
                    this.bgmVolume = 0.5;
                    this.sfxVolume = 0.7;
                    this.bgmPlaying = false;
                    this.sfxEnabled = true;
                    this.initialized = false;
                    this.isMobile = isMobile.value;
                }

                async init() {
                    if (this.initialized) return;
                    if (!this.isMobile && window.AudioContext) {
                        try {
                            await this.initWebAudio();
                            this.useWebAudio = true;
                        } catch (e) {
                            console.warn('WebAudioÂàùÂßãÂåñÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®ÊñπÊ°à', e);
                            this.initFallback();
                        }
                    } else {
                        this.initFallback();
                    }
                    this.initialized = true;
                }

                detectMobile() {
                    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                           (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
                }

                async initWebAudio() {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.bgmGainNode = this.audioContext.createGain();
                    this.sfxGainNode = this.audioContext.createGain();
                    this.bgmGainNode.connect(this.audioContext.destination);
                    this.sfxGainNode.connect(this.audioContext.destination);
                    this.bgmGainNode.gain.value = this.bgmVolume;
                    this.sfxGainNode.gain.value = this.sfxVolume;
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                }

                initFallback() {
                    this.useWebAudio = false;
                }

                async loadAudioBuffer(url) {
                    if (!this.useWebAudio || !this.audioContext) return null;
                    try {
                        const res = await fetch(url);
                        const buf = await res.arrayBuffer();
                        return await this.audioContext.decodeAudioData(buf);
                    } catch (e) {
                        console.error('Âä†ËΩΩÈü≥È¢ëÁºìÂÜ≤Âå∫Â§±Ë¥•', e);
                        return null;
                    }
                }

                async playBgm(src) {
                    if (!this.initialized) await this.init();
                    if (this.useWebAudio) {
                        await this.playBgmWebAudio(src);
                    } else {
                        await this.playBgmFallback(src);
                    }
                }

                async playBgmWebAudio(src) {
                    try {
                        if (this.audioContext.state === 'suspended') {
                            await this.audioContext.resume();
                        }
                        if (this.bgmSource) this.bgmSource.stop();
                        
                        this.bgmBuffer = await this.loadAudioBuffer(src);
                        if (!this.bgmBuffer) {
                            console.warn('WebAudioÂä†ËΩΩBGMÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®ÊñπÊ°à');
                            return await this.playBgmFallback(src);
                        }
                        
                        this.bgmSource = this.audioContext.createBufferSource();
                        this.bgmSource.buffer = this.bgmBuffer;
                        this.bgmSource.loop = true;
                        this.bgmSource.connect(this.bgmGainNode);
                        this.bgmSource.start();
                        this.bgmPlaying = true;
                        bgmPlaying.value = true;
                    } catch (e) {
                        console.error('WebAudioÊí≠ÊîæBGMÂ§±Ë¥•', e);
                        await this.playBgmFallback(src);
                    }
                }

                async playBgmFallback(src) {
                    try {
                        if (this.bgmAudio) this.bgmAudio.pause();
                        
                        this.bgmAudio = new Audio(src);
                        this.bgmAudio.loop = true;
                        this.bgmAudio.volume = this.bgmVolume;
                        
                        if (this.isMobile) this.bgmAudio.load();
                        const playPromise = this.bgmAudio.play();
                        if (playPromise) await playPromise;
                        
                        this.bgmPlaying = true;
                        bgmPlaying.value = true;
                    } catch (e) {
                        console.error('Êí≠ÊîæBGMÂ§±Ë¥•', e);
                        this.bgmPlaying = false;
                        bgmPlaying.value = false;
                        throw e;
                    }
                }

                async playSfx(name) {
                    if (!this.sfxEnabled || !this.initialized) return;
                    const src = sfxMap[name];
                    if (!src) return;
                    
                    if (this.useWebAudio) {
                        await this.playSfxWebAudio(name, src);
                    } else {
                        await this.playSfxFallback(name, src);
                    }
                }

                async playSfxWebAudio(name, src) {
                    try {
                        if (this.audioContext.state === 'suspended') {
                            await this.audioContext.resume();
                        }
                        
                        if (!this.sfxBuffers.has(name)) {
                            const buffer = await this.loadAudioBuffer(src);
                            if (buffer) this.sfxBuffers.set(name, buffer);
                        }
                        
                        const buffer = this.sfxBuffers.get(name);
                        if (!buffer) {
                            console.warn('WebAudioÂä†ËΩΩÈü≥ÊïàÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®ÊñπÊ°à');
                            return await this.playSfxFallback(name, src);
                        }
                        
                        const source = this.audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.connect(this.sfxGainNode);
                        source.start();
                    } catch (e) {
                        console.error('Êí≠ÊîæÈü≥ÊïàÂ§±Ë¥•', e);
                        await this.playSfxFallback(name, src);
                    }
                }

                async playSfxFallback(name, src) {
                    try {
                        if (!this.sfxAudioPool.has(name)) {
                            this.sfxAudioPool.set(name, []);
                        }
                        const pool = this.sfxAudioPool.get(name);
                        
                        let audio = pool.find(a => a.paused || a.ended);
                        if (!audio) {
                            audio = new Audio(src);
                            audio.volume = this.sfxVolume;
                            pool.push(audio);
                            if (pool.length > 3) pool.shift();
                        }
                        
                        audio.currentTime = 0;
                        audio.volume = this.sfxVolume;
                        const playPromise = audio.play();
                        if (playPromise) await playPromise;
                    } catch (e) {
                        console.error('Â§áÁî®ÊñπÊ°àÊí≠ÊîæÈü≥ÊïàÂ§±Ë¥•', e);
                    }
                }

                setBgmVolume(volume) {
                    this.bgmVolume = Math.max(0, Math.min(1, volume));
                    if (this.useWebAudio && this.bgmGainNode) {
                        this.bgmGainNode.gain.value = this.bgmVolume;
                    } else if (this.bgmAudio) {
                        this.bgmAudio.volume = this.bgmVolume;
                    }
                }

                setSfxVolume(volume) {
                    this.sfxVolume = Math.max(0, Math.min(1, volume));
                    if (this.useWebAudio && this.sfxGainNode) {
                        this.sfxGainNode.gain.value = this.sfxVolume;
                    }
                    this.sfxAudioPool.forEach(pool => {
                        pool.forEach(audio => {
                            audio.volume = this.sfxVolume;
                        });
                    });
                }

                pauseBgm() {
                    if (this.useWebAudio && this.bgmSource && this.bgmPlaying) {
                        this.bgmSource.stop();
                    } else if (this.bgmAudio && !this.bgmAudio.paused) {
                        this.bgmAudio.pause();
                    }
                    this.bgmPlaying = false;
                    bgmPlaying.value = false;
                }

                resumeBgm() {
                    if (this.useWebAudio && this.bgmBuffer && !this.bgmPlaying) {
                        try {
                            this.bgmSource = this.audioContext.createBufferSource();
                            this.bgmSource.buffer = this.bgmBuffer;
                            this.bgmSource.loop = true;
                            this.bgmSource.connect(this.bgmGainNode);
                            this.bgmSource.start();
                            this.bgmPlaying = true;
                            bgmPlaying.value = true;
                        } catch (e) {
                            console.error('ÊÅ¢Â§çBGMÂ§±Ë¥•', e);
                        }
                    } else if (this.bgmAudio && this.bgmAudio.paused) {
                        this.bgmAudio.play()
                            .then(() => {
                                this.bgmPlaying = true;
                                bgmPlaying.value = true;
                            })
                            .catch(e => console.error('ÊÅ¢Â§çBGMÂ§±Ë¥•', e));
                    }
                }

                toggleSfx() {
                    this.sfxEnabled = !this.sfxEnabled;
                    sfxEnabled.value = this.sfxEnabled;
                    return this.sfxEnabled;
                }
            }

            const audioManager = new HybridAudioManager();

            const updateAudioSources = (cdnUrl) => {
                bgmList.value.forEach(bgm => {
                    bgm.src = `${cdnUrl}/audio/bgm/bgm_${bgm.id}.mp3`;
                });
                Object.keys(sfxMap).forEach(key => {
                    sfxMap[key] = `${cdnUrl}/audio/sfx/${key}.mp3`;
                });
                console.log(`ËµÑÊ∫êË∑ØÂæÑÂ∑≤Êõ¥Êñ∞Ëá≥: ${cdnUrl}`);
            };

            const switchBgm = async (bgm) => {
                if (currentBgmId.value === bgm.id) return;
                try {
                    await playSfx('click');
                    currentBgmId.value = bgm.id;
                    localStorage.setItem('last_played_bgm_id', bgm.id.toString());
                    await audioManager.playBgm(bgm.src);
                } catch (e) {
                    emitter.emit('showMessage', { 
                        text: 'BGM ÂàáÊç¢Â§±Ë¥•', 
                        type: 'error' 
                    });
                }
            };

            const playLastOrDefaultBgm = async () => {
                const savedId = localStorage.getItem('last_played_bgm_id');
                const bgm = bgmList.value.find(b => b.id === parseInt(savedId, 10)) || bgmList.value[0];
                if (bgm && bgm.src) {
                    try {
                        await audioManager.playBgm(bgm.src);
                        currentBgmId.value = bgm.id;
                    } catch (e) {
                        emitter.emit('showMessage', { 
                            text: 'BGM Âä†ËΩΩÂ§±Ë¥•', 
                            type: 'error' 
                        });
                    }
                }
            };

            const toggleBgm = () => {
                if (bgmPlaying.value) {
                    audioManager.pauseBgm();
                } else {
                    audioManager.resumeBgm();
                }
            };

            const toggleSfx = () => {
                audioManager.toggleSfx();
            };

            const playSfx = async (name) => {
                try {
                    await audioManager.playSfx(name);
                } catch (e) {
                    console.warn(`Êí≠ÊîæÈü≥Êïà${name}Â§±Ë¥•`, e);
                }
            };

            const updateBgmVolume = () => {
                audioManager.setBgmVolume(bgmVolume.value / 100);
                localStorage.setItem('bgm_volume', bgmVolume.value);
            };

            const updateSfxVolume = () => {
                audioManager.setSfxVolume(sfxVolumePercent.value / 100);
                localStorage.setItem('sfx_volume', sfxVolumePercent.value);
            };

            const loadSettings = () => {
                const savedBgmVolume = localStorage.getItem('bgm_volume');
                const savedSfxVolume = localStorage.getItem('sfx_volume');
                
                if (savedBgmVolume) bgmVolume.value = parseInt(savedBgmVolume, 10);
                if (savedSfxVolume) sfxVolumePercent.value = parseInt(savedSfxVolume, 10);
                
                updateBgmVolume();
                updateSfxVolume();
            };

            const initAudio = async () => {
                try {
                    await audioManager.init();
                } catch (e) {
                    console.error('ÂàùÂßãÂåñÈü≥È¢ëÁÆ°ÁêÜÂô®Â§±Ë¥•', e);
                }
            };

            return {
                bgmList,
                bgmPlaying,
                sfxEnabled,
                currentBgmId,
                bgmVolume,
                sfxVolumePercent,
                isMobile,
                updateAudioSources,
                switchBgm,
                playLastOrDefaultBgm,
                toggleBgm,
                toggleSfx,
                playSfx,
                updateBgmVolume,
                updateSfxVolume,
                loadSettings,
                initAudio,
                audioManager
            };
        };

        // Ê∏∏ÊàèÈÄªËæëÊ®°Âùó
        const useGameLogic = (audio) => {
            const boardSize = ref(8);
            const tileTypes = 6;
            const gameBoard = ref([]);
            const selectedTile = ref(null);
            const isSwapping = ref(false);
            const isChecking = ref(false);
            const matchedTiles = ref(new Set());
            const shakingTile = ref(null);
            const chainCount = ref(0);
            const particles = ref([]);
            const score = ref(0);
            const movesUsed = ref(0);
            const gameTime = ref(0);
            const gameTimer = ref(null);
            const gameStarted = ref(false);
            const showGameOver = ref(false);
            const isPaused = ref(false);
            const gameState = ref('menu');

            // ÂàùÂßãÂåñÊ£ãÁõò
            const initializeBoard = () => {
                const newBoard = [];
                for (let row = 0; row < boardSize.value; row++) {
                    newBoard[row] = [];
                    for (let col = 0; col < boardSize.value; col++) {
                        let type;
                        // Á°Æ‰øù‰∏ç‰ºöÂàùÂßãÂ∞±Âá∫Áé∞3‰∏™ËøûÁª≠Áõ∏ÂêåÁöÑÊñπÂùó
                        do {
                            type = Math.floor(Math.random() * tileTypes) + 1;
                        } while (
                            (col >= 2 && newBoard[row][col-1].type === type && newBoard[row][col-2].type === type) ||
                            (row >= 2 && newBoard[row-1][col].type === type && newBoard[row-2][col].type === type)
                        );
                        newBoard[row][col] = {
                            type,
                            id: `tile-${row}-${col}-${Date.now()}-${Math.random()}`
                        };
                    }
                }
                gameBoard.value = newBoard;
                return newBoard;
            };

            // Ê£ÄÊü•Áõ∏ÈÇªÊñπÂùó
            const areAdjacent = (tile1, tile2) => {
                return Math.abs(tile1.row - tile2.row) + Math.abs(tile1.col - tile2.col) === 1;
            };

            // Ê£ÄÊµãÂåπÈÖç
            const detectMatches = (board) => {
                const matches = new Set();
                
                // Ê£ÄÊµãÊ∞¥Âπ≥ÂåπÈÖç
                for (let row = 0; row < boardSize.value; row++) {
                    for (let col = 0; col < boardSize.value - 2; col++) {
                        if (board[row][col].type !== 0 && 
                            board[row][col].type === board[row][col+1].type && 
                            board[row][col].type === board[row][col+2].type) {
                            
                            matches.add(`${row}-${col}`);
                            matches.add(`${row}-${col+1}`);
                            matches.add(`${row}-${col+2}`);
                        }
                    }
                }
                
                // Ê£ÄÊµãÂûÇÁõ¥ÂåπÈÖç
                for (let col = 0; col < boardSize.value; col++) {
                    for (let row = 0; row < boardSize.value - 2; row++) {
                        if (board[row][col].type !== 0 && 
                            board[row][col].type === board[row+1][col].type && 
                            board[row][col].type === board[row+2][col].type) {
                            
                            matches.add(`${row}-${col}`);
                            matches.add(`${row+1}-${col}`);
                            matches.add(`${row+2}-${col}`);
                        }
                    }
                }
                
                return Array.from(matches).map(key => {
                    const [row, col] = key.split('-').map(Number);
                    return { row, col };
                });
            };

            // ÂÖãÈöÜÊ£ãÁõò
            const cloneBoard = (board) => {
                return board.map(row => row.map(tile => ({ ...tile })));
            };

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂèØË°åÁöÑÁßªÂä®
            const hasPossibleMove = (board) => {
                for (let row = 0; row < boardSize.value; row++) {
                    for (let col = 0; col < boardSize.value; col++) {
                        // Â∞ùËØïÂêëÂè≥‰∫§Êç¢
                        if (col < boardSize.value - 1) {
                            const tempBoard = cloneBoard(board);
                            [tempBoard[row][col], tempBoard[row][col+1]] = 
                            [tempBoard[row][col+1], tempBoard[row][col]];
                            
                            if (detectMatches(tempBoard).length > 0) {
                                return true;
                            }
                        }
                        
                        // Â∞ùËØïÂêë‰∏ã‰∫§Êç¢
                        if (row < boardSize.value - 1) {
                            const tempBoard = cloneBoard(board);
                            [tempBoard[row][col], tempBoard[row+1][col]] = 
                            [tempBoard[row+1][col], tempBoard[row][col]];
                            
                            if (detectMatches(tempBoard).length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            };

            // Â§ÑÁêÜÊñπÂùóÁÇπÂáª
            const handleTileClick = (tile) => {
                const targetTile = { row: tile.row, col: tile.col };
                
                if (!selectedTile.value) {
                    selectedTile.value = targetTile;
                    audio.playSfx('click');
                } else {
                    // ÁÇπÂáªÂ∑≤ÈÄâ‰∏≠ÁöÑÊñπÂùóÔºåÂèñÊ∂àÈÄâ‰∏≠
                    if (selectedTile.value.row === targetTile.row && 
                        selectedTile.value.col === targetTile.col) {
                        selectedTile.value = null;
                    } 
                    // ÁÇπÂáªÁõ∏ÈÇªÊñπÂùóÔºåÂ∞ùËØï‰∫§Êç¢
                    else if (areAdjacent(selectedTile.value, targetTile)) {
                        const firstTile = selectedTile.value;
                        selectedTile.value = null;
                        attemptSwap(firstTile, targetTile);
                    } 
                    // ÁÇπÂáªÈùûÁõ∏ÈÇªÊñπÂùóÔºåÊèêÁ§∫ÈîôËØØ
                    else {
                        audio.playSfx('error');
                        shakingTile.value = targetTile;
                        setTimeout(() => {
                            shakingTile.value = null;
                        }, 400);
                        emitter.emit('showMessage', { 
                            text: 'Âè™ËÉΩ‰∏éÁõ∏ÈÇªÁöÑÊñπÂùó‰∫§Êç¢!', 
                            type: 'error' 
                        });
                        selectedTile.value = targetTile;
                    }
                }
            };

            // Â∞ùËØï‰∫§Êç¢ÊñπÂùó
            const attemptSwap = async (tile1, tile2) => {
                isSwapping.value = true;
                movesUsed.value++;
                audio.playSfx('swap');
                
                // ÂÖãÈöÜÊ£ãÁõòÂπ∂‰∫§Êç¢ÊñπÂùó
                const tempBoard = cloneBoard(gameBoard.value);
                [tempBoard[tile1.row][tile1.col], tempBoard[tile2.row][tile2.col]] = 
                [tempBoard[tile2.row][tile2.col], tempBoard[tile1.row][tile1.col]];
                
                // Ê£ÄÊü•‰∫§Êç¢ÂêéÊòØÂê¶ÊúâÂåπÈÖç
                const matches = detectMatches(tempBoard);
                gameBoard.value = tempBoard;
                await nextTick();
                
                if (matches.length > 0) {
                    await new Promise(resolve => setTimeout(resolve, 150));
                    await processMatches(matches);
                } else {
                    // Êó†ÂåπÈÖçÔºå‰∫§Êç¢ÂõûÊù•
                    emitter.emit('showMessage', { 
                        text: 'Êó†ÊïàÁßªÂä®', 
                        type: 'error' 
                    });
                    audio.playSfx('error');
                    
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const revertBoard = cloneBoard(gameBoard.value);
                    [revertBoard[tile1.row][tile1.col], revertBoard[tile2.row][tile2.col]] = 
                    [revertBoard[tile2.row][tile2.col], revertBoard[tile1.row][tile1.col]];
                    
                    gameBoard.value = revertBoard;
                }
                
                isSwapping.value = false;
            };

            // Â§ÑÁêÜÂåπÈÖç
            const processMatches = async (matches) => {
                isChecking.value = true;
                chainCount.value++;
                
                // ÊòæÁ§∫ËøûÈîÅÊïàÊûú
                if (chainCount.value > 1) {
                    emitter.emit('showMessage', { 
                        text: `ËøûÈîÅÂèçÂ∫î x${chainCount.value}!`, 
                        type: 'chain' 
                    });
                    emitter.emit('showChainEffect', true);
                    setTimeout(() => {
                        emitter.emit('showChainEffect', false);
                    }, 1000);
                    audio.playSfx('match');
                } else {
                    audio.playSfx('match');
                }
                
                // ËÆ°ÁÆóÂàÜÊï∞Âπ∂ËÆ∞ÂΩïÂåπÈÖçÁöÑÊñπÂùó
                score.value += matches.length * 10 * chainCount.value;
                matchedTiles.value.clear();
                
                matches.forEach(tile => {
                    matchedTiles.value.add(`${tile.row}-${tile.col}`);
                    createParticleEffect(tile.row, tile.col);
                });
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Ê∏ÖÈô§ÂåπÈÖçÁöÑÊñπÂùó
                const newBoard = cloneBoard(gameBoard.value);
                matches.forEach(tile => {
                    newBoard[tile.row][tile.col].type = 0;
                });
                
                matchedTiles.value.clear();
                gameBoard.value = newBoard;
                
                // Â§ÑÁêÜÊñπÂùó‰∏ãËêΩÂíåÂ°´ÂÖÖÊñ∞ÊñπÂùó
                await handleFall();
                await fillNewTiles();
                isChecking.value = false;
                
                // Ê£ÄÊü•ÊòØÂê¶ÊúâÊñ∞ÁöÑÂåπÈÖç
                const newMatches = detectMatches(gameBoard.value);
                if (newMatches.length > 0) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    await processMatches(newMatches);
                } else {
                    chainCount.value = 0;
                    // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÂèØËÉΩÁöÑÁßªÂä®
                    if (!hasPossibleMove(gameBoard.value)) {
                        audio.playSfx('nomove');
                        emitter.emit('showMessage', { 
                            text: 'Ê≤°ÊúâÂèØÁßªÂä®ÁöÑÊ≠•Êï∞‰∫Ü!', 
                            type: 'error',
                            duration: 2000 
                        });
                        gameState.value = 'gameover';
                        setTimeout(() => {
                            endGame();
                        }, 2000);
                    }
                }
            };

            // Â§ÑÁêÜÊñπÂùó‰∏ãËêΩ
            const handleFall = async () => {
                audio.playSfx('fall');
                const newBoard = cloneBoard(gameBoard.value);
                
                // ÊØèÂàóÂ§ÑÁêÜ‰∏ãËêΩ
                for (let col = 0; col < boardSize.value; col++) {
                    let emptyRow = boardSize.value - 1;
                    // ‰ªéÂ∫ïÈÉ®Âêë‰∏äÁßªÂä®ÈùûÁ©∫ÊñπÂùó
                    for (let row = boardSize.value - 1; row >= 0; row--) {
                        if (newBoard[row][col].type !== 0) {
                            if (emptyRow !== row) {
                                newBoard[emptyRow][col] = newBoard[row][col];
                                newBoard[row][col].type = 0;
                            }
                            emptyRow--;
                        }
                    }
                }
                
                gameBoard.value = newBoard;
                await new Promise(resolve => setTimeout(resolve, 350));
            };

            // Â°´ÂÖÖÊñ∞ÊñπÂùó
            const fillNewTiles = async () => {
                const newBoard = cloneBoard(gameBoard.value);
                let hasNewTiles = false;
                
                // Â°´ÂÖÖÁ©∫ÁôΩ‰ΩçÁΩÆ
                for (let row = 0; row < boardSize.value; row++) {
                    for (let col = 0; col < boardSize.value; col++) {
                        if (newBoard[row][col].type === 0) {
                            hasNewTiles = true;
                            newBoard[row][col] = {
                                type: Math.floor(Math.random() * tileTypes) + 1,
                                id: `tile-${row}-${col}-${Date.now()}-${Math.random()}`
                            };
                        }
                    }
                }
                
                if (hasNewTiles) {
                    gameBoard.value = newBoard;
                    await nextTick();
                }
            };

            // ÂàõÂª∫Á≤íÂ≠êÊïàÊûú
            const createParticleEffect = (row, col) => {
                emitter.emit('createParticles', { row, col, boardSize: boardSize.value });
            };

            // ÂºÄÂßãÊ∏∏Êàè
            const startGame = async () => {
                if (audio.isMobile) {
                    // ÁßªÂä®Á´ØÈúÄË¶ÅÁî®Êà∑‰∫§‰∫íÊâçËÉΩÊí≠ÊîæÈü≥È¢ë
                    await audio.audioManager.init();
                }
                
                await audio.playSfx('click');
                gameStarted.value = true;
                isPaused.value = false;
                gameState.value = 'playing';
                score.value = 0;
                movesUsed.value = 0;
                gameTime.value = 0;
                chainCount.value = 0;
                selectedTile.value = null;
                showGameOver.value = false;
                
                initializeBoard();
                
                if (gameTimer.value) clearInterval(gameTimer.value);
                gameTimer.value = setInterval(() => {
                    if (!isPaused.value) gameTime.value++;
                }, 1000);
                
                await audio.playLastOrDefaultBgm();
            };

            // ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
            const restartGame = () => {
                if (gameTimer.value) clearInterval(gameTimer.value);
                startGame();
            };

            // ÁªìÊùüÊ∏∏Êàè
            const endGame = () => {
                showGameOver.value = true;
                if (gameTimer.value) {
                    clearInterval(gameTimer.value);
                    gameTimer.value = null;
                }
                audio.audioManager.pauseBgm();
                audio.playSfx('win');
            };

            // ÂàáÊç¢ÊöÇÂÅúÁä∂ÊÄÅ
            const togglePause = () => {
                if (!gameStarted.value || showGameOver.value) return;
                
                isPaused.value = !isPaused.value;
                
                if (isPaused.value) {
                    // ÊöÇÂÅúÊ∏∏Êàè
                    if (gameTimer.value) {
                        clearInterval(gameTimer.value);
                        gameTimer.value = null;
                    }
                    audio.audioManager.pauseBgm();
                    gameState.value = 'paused';
                } else {
                    // ÊÅ¢Â§çÊ∏∏Êàè
                    gameTimer.value = setInterval(() => {
                        gameTime.value++;
                    }, 1000);
                    audio.audioManager.resumeBgm();
                    gameState.value = 'playing';
                }
                
                audio.playSfx('click');
            };

            // Â§ÑÁêÜÊ£ãÁõòÂ§ßÂ∞èÂèòÂåñ
            const handleBoardSizeChange = () => {
                if (gameStarted.value) {
                    restartGame();
                }
            };

            return {
                boardSize,
                gameBoard,
                selectedTile,
                isSwapping,
                isChecking,
                matchedTiles,
                shakingTile,
                chainCount,
                particles,
                score,
                movesUsed,
                gameTime,
                gameTimer,
                gameStarted,
                showGameOver,
                isPaused,
                gameState,
                initializeBoard,
                detectMatches,
                cloneBoard,
                hasPossibleMove,
                handleTileClick,
                attemptSwap,
                processMatches,
                handleFall,
                fillNewTiles,
                createParticleEffect,
                startGame,
                restartGame,
                endGame,
                togglePause,
                handleBoardSizeChange
            };
        };

        // UIÁä∂ÊÄÅÁÆ°ÁêÜÊ®°Âùó
        const useUIState = (game, audio) => {
            const showLoading = ref(true);
            const loadingProgress = ref(0);
            const loadingError = ref('');
            const showSettings = ref(false);
            const showMessage = ref(false);
            const message = ref('');
            const messageType = ref('info');
            const showChainEffect = ref(false);
            const imageLoadErrors = ref(new Set());
            const particleCanvas = ref(null);
            const canvasCtx = ref(null);

            // CDNÈÖçÁΩÆ
            const CDN_OPTIONS = {
                jsdelivr: 'https://cdn.jsdelivr.net/gh/EricSmith123/game-assets@main',
                github: 'https://raw.githubusercontent.com/EricSmith123/game-assets/main',
                local: './assets' // Êú¨Âú∞ fallback
            };
            let CURRENT_CDN = CDN_OPTIONS.jsdelivr;

            // Ê†ºÂºèÂåñÊó∂Èó¥
            const formattedTime = computed(() => {
                const minutes = Math.floor(game.gameTime.value / 60);
                const seconds = game.gameTime.value % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            });

            // Ê£ãÁõòÊ†∑Âºè
            const boardStyle = computed(() => ({
                gridTemplateColumns: `repeat(${game.boardSize.value}, 1fr)`
            }));

            // ÊâÅÂπ≥ÂåñÊ£ãÁõòÊï∞ÊçÆ
            const flatBoard = computed(() => {
                const flat = [];
                for (let row = 0; row < game.boardSize.value; row++) {
                    for (let col = 0; col < game.boardSize.value; col++) {
                        if (game.gameBoard.value[row] && game.gameBoard.value[row][col]) {
                            flat.push({ ...game.gameBoard.value[row][col], row, col });
                        }
                    }
                }
                return flat;
            });

            // Ëé∑ÂèñÊñπÂùóÊ†∑ÂºèÁ±ª
            const getTileClasses = (tile) => {
                const classes = [`tile-type-${tile.type}`];
                if (game.selectedTile.value && 
                    game.selectedTile.value.row === tile.row && 
                    game.selectedTile.value.col === tile.col) {
                    classes.push('selected');
                }
                if (game.matchedTiles.value.has(`${tile.row}-${tile.col}`)) {
                    classes.push('matched');
                }
                if (game.shakingTile.value && 
                    game.shakingTile.value.row === tile.row && 
                    game.shakingTile.value.col === tile.col) {
                    classes.push('shake');
                }
                return classes;
            };

            // Ëé∑ÂèñÊñπÂùóÂõæÁâáË∑ØÂæÑ
            const getTileImage = (type) => {
                if (type < 1 || type > 6) return '';
                return `${CURRENT_CDN}/tiles/tile-${type}.webp`;
            };

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂèØÁî®ÂõæÁâá
            const hasImage = (type) => {
                return type >= 1 && type <= 6 && !imageLoadErrors.value.has(type);
            };

            // Ëé∑ÂèñÊñπÂùóÁ¨¶Âè∑
            const getTileSymbol = (type) => {
                return ['', 'üêª', 'üê∞', 'üê±', 'üê∂', 'üê∏', 'üêº'][type] || '';
            };

            // Â§ÑÁêÜÂõæÁâáÂä†ËΩΩÈîôËØØ
            const handleImageError = (type) => {
                imageLoadErrors.value.add(type);
                console.warn(`ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•: tile-${type}.webp`);
            };

            // Â§ÑÁêÜÂ§ñÈÉ®ÁÇπÂáª
            const handleOutsideClick = () => {
                game.selectedTile.value = null;
            };

            // ÊòæÁ§∫Ê∂àÊÅØ
            const showMessageHandler = (payload) => {
                message.value = payload.text;
                messageType.value = payload.type || 'info';
                showMessage.value = true;
                setTimeout(() => {
                    showMessage.value = false;
                }, payload.duration || 1200);
            };

            // ÊòæÁ§∫ËøûÈîÅÊïàÊûú
            const showChainEffectHandler = (show) => {
                showChainEffect.value = show;
            };

            // Ê£ÄÊµãÊúÄ‰Ω≥CDN
            const detectBestCDN = async () => {
                for (const [name, baseUrl] of Object.entries(CDN_OPTIONS)) {
                    try {
                        const testUrl = `${baseUrl}/test.txt?t=${Date.now()}`;
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 3000);
                        
                        const response = await fetch(testUrl, { 
                            method: 'HEAD', 
                            signal: controller.signal 
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            console.log(`‰ΩøÁî®CDN: ${name}`);
                            CURRENT_CDN = baseUrl;
                            return true;
                        }
                    } catch (error) {
                        console.warn(`CDN ${name} Ê£ÄÊµãÂ§±Ë¥•`);
                    }
                }
                
                console.error('ÊâÄÊúâCDNÈÉΩÊ£ÄÊµãÂ§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî®Êú¨Âú∞ËµÑÊ∫ê');
                CURRENT_CDN = CDN_OPTIONS.local;
                return false;
            };

            // Âä†ËΩΩËµÑÊ∫ê
            const loadResources = async () => {
                try {
                    loadingProgress.value = 10;
                    
                    // Ê£ÄÊµãCDN
                    const cdnAvailable = await detectBestCDN();
                    loadingProgress.value = 20;
                    
                    if (!cdnAvailable) {
                        loadingError.value = 'ËµÑÊ∫êÊúçÂä°Âô®ËøûÊé•Â§±Ë¥•ÔºåÂèØËÉΩÂΩ±ÂìçÊ∏∏Êàè‰ΩìÈ™å';
                    }
                    
                    // Êõ¥Êñ∞Èü≥È¢ëËµÑÊ∫êË∑ØÂæÑ
                    audio.updateAudioSources(CURRENT_CDN);
                    
                    // ÂàùÂßãÂåñÈü≥È¢ë
                    await audio.initAudio();
                    loadingProgress.value = 30;
                    
                    // È¢ÑÂä†ËΩΩÂõæÁâá
                    const imageTypes = Array.from({ length: 6 }, (_, i) => i + 1);
                    const totalImages = imageTypes.length;
                    let loadedImages = 0;
                    
                    const loadImage = (type) => {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.src = getTileImage(type);
                            img.onload = () => {
                                loadedImages++;
                                loadingProgress.value = 30 + Math.floor((loadedImages / totalImages) * 65);
                                resolve();
                            };
                            img.onerror = () => {
                                handleImageError(type);
                                loadedImages++;
                                loadingProgress.value = 30 + Math.floor((loadedImages / totalImages) * 65);
                                resolve();
                            };
                        });
                    };

                    // Âπ∂ÂèëÈôêÂà∂‰∏∫3‰∏™
                    const concurrency = 3;
                    const batches = [];
                    for (let i = 0; i < imageTypes.length; i += concurrency) {
                        batches.push(imageTypes.slice(i, i + concurrency));
                    }

                    for (const batch of batches) {
                        await Promise.all(batch.map(type => loadImage(type)));
                    }

                    loadingProgress.value = 95;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    loadingProgress.value = 100;
                    
                    setTimeout(() => {
                        showLoading.value = false;
                    }, 300);
                    
                    return true;
                } catch (error) {
                    console.error('ËµÑÊ∫êÂä†ËΩΩÂ§±Ë¥•', error);
                    loadingError.value = 'ËµÑÊ∫êÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•';
                    return false;
                }
            };

            // ÈáçËØïÂä†ËΩΩ
            const retryLoading = () => {
                loadingError.value = '';
                imageLoadErrors.value.clear();
                loadResources();
            };

            // ÂàùÂßãÂåñÁ≤íÂ≠êÁîªÂ∏É
            const initParticleCanvas = () => {
                if (!particleCanvas.value) return;
                
                const canvas = particleCanvas.value;
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                canvas.width = rect.width;
                canvas.height = rect.height;
                canvasCtx.value = canvas.getContext('2d');
                
                // Á≤íÂ≠êÂä®ÁîªÂæ™ÁéØ
                const animateParticles = () => {
                    if (!canvasCtx.value) return;
                    
                    canvasCtx.value.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // ÁªòÂà∂Á≤íÂ≠ê
                    game.particles.value.forEach(particle => {
                        canvasCtx.value.fillStyle = '#ffd700';
                        canvasCtx.value.beginPath();
                        canvasCtx.value.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                        canvasCtx.value.fill();
                        
                        // Êõ¥Êñ∞Á≤íÂ≠ê‰ΩçÁΩÆ
                        particle.y -= 2;
                        particle.alpha -= 0.02;
                    });
                    
                    // ÁßªÈô§Ê∂àÂ§±ÁöÑÁ≤íÂ≠ê
                    game.particles.value = game.particles.value.filter(p => p.alpha > 0);
                    
                    requestAnimationFrame(animateParticles);
                };
                
                animateParticles();
            };

            // ÂàõÂª∫Á≤íÂ≠ê
            const createParticlesHandler = (data) => {
                if (!canvasCtx.value || !particleCanvas.value) return;
                
                const { row, col, boardSize } = data;
                const canvas = particleCanvas.value;
                const tileSize = canvas.width / boardSize;
                const x = col * tileSize + tileSize / 2;
                const y = row * tileSize + tileSize / 2;
                
                // ÂàõÂª∫5‰∏™Á≤íÂ≠ê
                for (let i = 0; i < 5; i++) {
                    game.particles.value.push({
                        id: Math.random(),
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        alpha: 1
                    });
                }
            };

            // ÊâìÂºÄËÆæÁΩÆÈù¢Êùø
            const openSettings = () => {
                if (game.gameStarted.value && !game.showGameOver.value && game.gameTimer.value) {
                    clearInterval(game.gameTimer.value);
                    game.gameTimer.value = null;
                }
                showSettings.value = true;
            };

            // ÂÖ≥Èó≠ËÆæÁΩÆÈù¢Êùø
            const closeSettings = () => {
                showSettings.value = false;
                if (game.gameStarted.value && !game.showGameOver.value && 
                    game.gameTimer.value === null && !game.isPaused.value) {
                    game.gameTimer.value = setInterval(() => {
                        game.gameTime.value++;
                    }, 1000);
                }
            };

            // ÈáçÁΩÆËÆæÁΩÆ
            const resetSettings = () => {
                audio.bgmVolume.value = 50;
                audio.sfxVolumePercent.value = 70;
                game.boardSize.value = 8;
                
                audio.updateBgmVolume();
                audio.updateSfxVolume();
                
                localStorage.removeItem('bgm_volume');
                localStorage.removeItem('sfx_volume');
                localStorage.removeItem('board_size');
                
                emitter.emit('showMessage', { 
                    text: 'ËÆæÁΩÆÂ∑≤ÈáçÁΩÆ', 
                    type: 'success' 
                });
            };

            // Èò≤ÊäñÂáΩÊï∞
            const debounce = (func, wait) => {
                let timeout;
                return function(...args) {
                    const context = this;
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(context, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            };

            // ÂàùÂßãÂåñ
            const initialize = async () => {
                emitter.on('showMessage', showMessageHandler);
                emitter.on('showChainEffect', showChainEffectHandler);
                emitter.on('createParticles', createParticlesHandler);
                
                await loadResources();
                audio.loadSettings();
                
                // ‰ªéÊú¨Âú∞Â≠òÂÇ®Âä†ËΩΩÊ£ãÁõòÂ§ßÂ∞èËÆæÁΩÆ
                const savedBoardSize = localStorage.getItem('board_size');
                if (savedBoardSize) {
                    game.boardSize.value = parseInt(savedBoardSize, 10);
}

// ÁõëÂê¨Ê£ãÁõòÂ§ßÂ∞èÂèòÂåñÂπ∂‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®
watch(
    () => game.boardSize.value,
    (newSize) => {
        localStorage.setItem('board_size', newSize.toString());
    }
);

// Èò≤ÊäñÂ§ÑÁêÜÊñπÂùóÁÇπÂáª
const debouncedTileClick = debounce((tile) => {
    if (game.isPaused.value || game.isSwapping.value || game.isChecking.value) return;
    game.handleTileClick(tile);
}, 100);

onMounted(() => {
    // ÂàùÂßãÂåñÁ≤íÂ≠êÁîªÂ∏É
    initParticleCanvas();
    
    // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñÔºåÈáçÊñ∞Ë∞ÉÊï¥ÁîªÂ∏É
    window.addEventListener('resize', initParticleCanvas);
    
    // ÁõëÂê¨È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÔºåÂ§ÑÁêÜÈü≥È¢ë
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && audio.bgmPlaying.value) {
            audio.audioManager.pauseBgm();
        } else if (!document.hidden && game.gameStarted.value && !game.isPaused.value) {
            audio.audioManager.resumeBgm();
        }
    });
});

onUnmounted(() => {
    window.removeEventListener('resize', initParticleCanvas);
    if (game.gameTimer.value) clearInterval(game.gameTimer.value);
    if (audio.audioManager.audioContext) {
        audio.audioManager.audioContext.close();
    }
    emitter.all.clear();
});

return {
    showLoading,
    loadingProgress,
    loadingError,
    showSettings,
    showMessage,
    message,
    messageType,
    showChainEffect,
    formattedTime,
    boardStyle,
    flatBoard,
    particleCanvas,
    getTileClasses,
    getTileImage,
    hasImage,
    getTileSymbol,
    handleImageError,
    handleOutsideClick,
    detectBestCDN,
    loadResources,
    retryLoading,
    openSettings,
    closeSettings,
    resetSettings,
    debouncedTileClick,
    ...game,
    ...audio
};
        };

        // ‰∏ªÂ∫îÁî®
        createApp({
            setup() {
                const audio = useAudioManager();
                const game = useGameLogic(audio);
                const ui = useUIState(game, audio);
                return { ...ui };
            }
        }).mount('#app');
    </script>
</body>
</html>
