<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç†Šç†Šæ¶ˆæ¶ˆä¹</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; }
        .game-container { width: 100%; background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; position: relative; margin: 10px; max-width: min(95vw, 500px); max-height: min(95vh, 700px); }
        .overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal { background: white; padding: 30px; border-radius: 15px; text-align: center; max-width: 350px; width: 90%; }
        .start-btn, .action-btn { background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white; border: none; padding: 15px 30px; border-radius: 25px; font-size: 18px; font-weight: bold; cursor: pointer; transition: transform 0.2s; touch-action: manipulation; }
        .start-btn:hover, .action-btn:hover { transform: scale(1.05); }
        .top-controls { position: absolute; top: 0; left: 0; right: 0; height: 60px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; z-index: 100; }
        .right-controls { display: flex; align-items: center; gap: 8px; }
        .bgm-selector { position: static; background: none; border-radius: 0; padding: 0; display: flex; gap: 5px; }
        .bgm-btn { background: rgba(255,255,255,0.3); border: none; color: white; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 11px; touch-action: manipulation; transition: all 0.2s; }
        .bgm-btn.active { background: rgba(255,255,255,0.8); color: #333; }
        .audio-btn, .settings-btn { background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px; border-radius: 50%; cursor: pointer; font-size: 14px; touch-action: manipulation; min-width: 32px; min-height: 32px; display: flex; align-items: center; justify-content: center; }
        .pause-btn { background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 12px; border-radius: 15px; cursor: pointer; font-size: 12px; touch-action: manipulation; }
        .action-btn.green { background: #27ae60; }
        .action-btn.green:hover { background: #229954; }
        .score-info { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; margin: -70px -20px 20px -20px; padding-top: 75px; border-radius: 0; display: flex; justify-content: space-around; align-items: center; }
        .score-box { text-align: center; }
        .score-label { display: block; font-size: 12px; opacity: 0.8; }
        .score-value { display: block; font-size: 18px; font-weight: bold; }
        .game-content { padding: 70px 15px 15px 15px; }
        .game-board-container { position: relative; }
        .game-board { width: min(95vw, 500px); height: min(95vw, 500px); max-width: 500px; max-height: 500px; margin: 0 auto; display: grid; gap: 2px; background: #f0f0f0; border-radius: 10px; padding: 10px; position: relative; }
        .game-tile { aspect-ratio: 1; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s ease; position: relative; user-select: none; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); touch-action: manipulation; font-size: 24px; font-weight: bold; }
        .game-tile img { width: 85%; height: 85%; object-fit: contain; pointer-events: none; }
        .game-tile:hover { transform: scale(1.05); }
        .game-tile.selected { transform: scale(1.1); box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); border: 3px solid gold; }
        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; z-index: 100; animation: fadeInOut 1.2s ease; }
        .message-box.error { background: rgba(255, 107, 107, 0.9); }
        .message-box.success { background: rgba(67, 233, 123, 0.9); }
        .message-box.chain { background: rgba(255, 215, 0, 0.9); color: #333; }
        .chain-effect { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 200; pointer-events: none; }
        .chain-text { font-size: 24px; font-weight: bold; color: #ff6b6b; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); animation: chainPulse 1s ease-out; }
        .particle-effect { position: absolute; pointer-events: none; z-index: 100; }
        .particle { position: absolute; width: 4px; height: 4px; background: #ffd700; border-radius: 50%; animation: particle-float 1s ease-out forwards; }
        .end-btn-row { display: flex; gap: 10px; margin-top: 20px; justify-content: center; }
        .action-btn.purple { background: linear-gradient(45deg, #667eea, #764ba2); }
        .action-btn.gray { background: linear-gradient(45deg, #bdc3c7, #95a5a6); }
        .tile-type-1 { background: linear-gradient(135deg, #8B4513, #A0522D); color: white; } .tile-type-2 { background: linear-gradient(135deg, #FFB6C1, #FFC0CB); color: #8B4513; } .tile-type-3 { background: linear-gradient(135deg, #FF8C00, #FFA500); color: white; } .tile-type-4 { background: linear-gradient(135deg, #8B4513, #D2691E); color: white; } .tile-type-5 { background: linear-gradient(135deg, #32CD32, #90EE90); color: #006400; } .tile-type-6 { background: linear-gradient(135deg, #000000, #696969); color: white; }
        @keyframes matchPulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); background: #ffd700; } 100% { transform: scale(1); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes fadeInOut { 0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        @keyframes chainPulse { 0% { transform: scale(0.5); opacity: 0; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
        @keyframes particle-float { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(0.5); } }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; justify-content: center; align-items: center; z-index: 9999; }
        .loading-content { text-align: center; color: white; max-width: 400px; padding: 40px; }
        .loading-spinner { width: 60px; height: 60px; border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 30px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .settings-panel { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 2000; }
        .settings-content { background: white; padding: 30px; border-radius: 15px; max-width: 400px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .settings-content h3 { margin: 0 0 20px 0; text-align: center; color: #333; }
        .setting-group { margin-bottom: 20px; }
        .setting-group label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        .setting-group input[type="range"] { width: 70%; margin-right: 10px; }
        .settings-actions { display: flex; gap: 10px; margin-top: 25px; }
        .settings-actions button { flex: 1; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; }
        .reset-btn { background: #ff6b6b; color: white; }
        .close-btn { background: #4ecdc4; color: white; }
        .settings-actions button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="showLoading" class="loading-overlay">
            <div class="loading-content"><div class="loading-spinner"></div><h2>ğŸ® æ¸¸æˆèµ„æºåŠ è½½ä¸­...</h2></div>
        </div>
        <div v-if="showSettings" class="settings-panel">
            <div class="settings-content">
                <h3>ğŸ® æ¸¸æˆè®¾ç½®</h3>
                <div class="setting-group"><label>ğŸµ BGMéŸ³é‡</label><input type="range" min="0" max="100" v-model="bgmVolume" @input="updateBgmVolume"><span>{{ bgmVolume }}%</span></div>
                <div class="setting-group"><label>ğŸ”Š éŸ³æ•ˆéŸ³é‡</label><input type="range" min="0" max="100" v-model="sfxVolumePercent" @input="updateSfxVolume"><span>{{ sfxVolumePercent }}%</span></div>
                <div class="settings-actions"><button @click="resetSettings" class="reset-btn">é‡ç½®è®¾ç½®</button><button @click="closeSettings" class="close-btn">å…³é—­</button></div>
            </div>
        </div>
        <div class="game-container">
            <div v-if="gameStarted" class="top-controls">
                <div class="bgm-selector"><button v-for="bgm in bgmList" :key="bgm.id" class="bgm-btn" :class="{ active: currentBgmId === bgm.id }" @click="switchBgm(bgm)">BGM{{ bgm.id }}</button></div>
                <div class="right-controls">
                    <button class="settings-btn" @click="openSettings" title="è®¾ç½®">âš™ï¸</button>
                    <button class="audio-btn" @click="toggleBgm" :title="bgmEnabled ? 'å…³é—­éŸ³ä¹' : 'å¼€å¯éŸ³ä¹'">{{ bgmEnabled ? 'ğŸ”Š' : 'ğŸ”‡' }}</button>
                    <button class="audio-btn" @click="toggleSfx" :title="sfxEnabled ? 'å…³é—­éŸ³æ•ˆ' : 'å¼€å¯éŸ³æ•ˆ'">{{ sfxEnabled ? 'ğŸµ' : 'ğŸ”•' }}</button>
                    <button class="pause-btn" @click="togglePause" v-if="!showGameOver">{{ isPaused ? 'â–¶ï¸' : 'â¸ï¸' }}</button>
                </div>
            </div>
            <div v-if="!gameStarted" class="overlay">
                <div class="modal"><h2 style="margin-bottom: 20px; color: #333;">ç†Šç†Šæ¶ˆæ¶ˆä¹</h2><button class="start-btn" @click="startGame">å¼€å§‹æ¸¸æˆ</button></div>
            </div>
            <div v-if="showGameOver" class="overlay">
                <div class="modal"><h3 style="margin-bottom: 15px; color: #e74c3c;">æ¸¸æˆç»“æŸ</h3><div style="margin-bottom: 20px; color: #666;"><p>æœ€ç»ˆåˆ†æ•°: {{ score }}</p><p>ä½¿ç”¨æ­¥æ•°: {{ movesUsed }}</p><p>æ¸¸æˆæ—¶é•¿: {{ formattedTime }}</p></div><div class="end-btn-row"><button class="action-btn purple" @click="restartGame">é‡æ–°å¼€å§‹</button></div></div>
            </div>
            <div v-if="isPaused" class="overlay">
                <div class="modal"><h3 style="margin-bottom: 15px; color: #3498db;">â¸ï¸ æ¸¸æˆæš‚åœ</h3><div style="margin-bottom: 20px; color: #666;"><p>å½“å‰åˆ†æ•°: {{ score }}</p><p>å·²ç”¨æ­¥æ•°: {{ movesUsed }}</p><p>æ¸¸æˆæ—¶é•¿: {{ formattedTime }}</p></div><div class="end-btn-row"><button class="action-btn green" @click="togglePause">ç»§ç»­æ¸¸æˆ</button><button class="action-btn gray" @click="restartGame">é‡æ–°å¼€å§‹</button></div></div>
            </div>
            <div class="game-content">
                <div class="score-info"><div class="score-box"><span class="score-label">åˆ†æ•°</span><span class="score-value">{{ score }}</span></div><div class="score-box"><span class="score-label">æ­¥æ•°</span><span class="score-value">{{ movesUsed }}</span></div><div class="score-box"><span class="score-label">æ—¶é—´</span><span class="score-value">{{ formattedTime }}</span></div></div>
                <div class="game-board-container">
                    <div class="game-board" :style="boardStyle" @click="handleOutsideClick">
                        <div v-for="tile in flatBoard" :key="tile.id" class="game-tile" :class="getTileClasses(tile)" @click.stop="handleTileClick(tile)">
                            <img v-if="hasImage(tile.type)" :src="getTileImage(tile.type)" :alt="getTileSymbol(tile.type)" @error="handleImageError" />
                            <span v-else>â“</span>
                        </div>
                    </div>
                    <div v-if="showMessage" class="message-box" :class="messageType">{{ message }}</div>
                    <div v-if="showChainEffect" class="chain-effect"><div class="chain-text">è¿é” x{{ chainCount }}</div></div>
                    <div class="particle-effect"><div v-for="p in particles" :key="p.id" class="particle" :style="{ top: p.y + 'px', left: p.x + 'px' }"></div></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, nextTick } = Vue;
        createApp({
            setup() {
                // --- é…ç½®åŒº ---
                const boardSize = 8;
                const tileTypes = 8; // *** FIX: æ ¹æ®æˆªå›¾ï¼Œæ‚¨çš„å›¾ç‰‡æœ‰8å¼  ***

                // --- çŠ¶æ€å˜é‡ ---
                const gameStarted = ref(false);
                const showGameOver = ref(false);
                const isPaused = ref(false);
                const showSettings = ref(false);
                const showLoading = ref(true);
                const score = ref(0);
                const movesUsed = ref(0);
                const gameTime = ref(0);
                const gameTimer = ref(null);
                const gameBoard = ref([]);
                const selectedTile = ref(null);
                const isProcessing = ref(false);
                const chainCount = ref(0);
                const particles = ref([]);
                const showMessage = ref(false);
                const message = ref('');
                const messageType = ref('info');
                const showChainEffect = ref(false);
                const bgmPlaying = ref(false);
                const bgmEnabled = ref(true);
                const sfxEnabled = ref(true);
                const currentBgmId = ref(1);
                const bgmVolume = ref(50);
                const sfxVolumePercent = ref(70);
                const imageLoadErrors = ref(new Set());
                const bgmAudio = ref(null);
                const sfxCache = new Map();
                const isAudioUnlocked = ref(false);

                // --- æ•°æ®å®šä¹‰ (æ ¹æ®æˆªå›¾ä¿®æ­£è·¯å¾„) ---
                const bgmList = ref([
                    { id: 1, name: "è½»æ¾BGM", src: './audio/bgm/bgm_1.mp3' },
                    { id: 2, name: "æ´»æ³¼BGM", src: './audio/bgm/bgm_2.mp3' }
                ]);
                const sfxMap = {
                    click: './audio/sfx/click.mp3', swap: './audio/sfx/swap.mp3',
                    match: './audio/sfx/match.mp3', error: './audio/sfx/error.mp3',
                    fall: './audio/sfx/fall.mp3', nomove: './audio/sfx/nomove.mp3',
                    countdown: './audio/sfx/countdown.mp3', lose: './audio/sfx/lose.mp3',
                    win: './audio/sfx/win.mp3'
                };
                
                // --- è®¡ç®—å±æ€§ ---
                const formattedTime = computed(() => {
                    const minutes = Math.floor(gameTime.value / 60);
                    const seconds = gameTime.value % 60;
                    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                });
                const boardStyle = computed(() => ({ gridTemplateColumns: `repeat(${boardSize}, 1fr)` }));
                const flatBoard = computed(() => gameBoard.value.flat());

                // --- æ ¸å¿ƒæ–¹æ³• ---
                const getTileImage = (type) => `./tiles/tile-${type}.webp`; // *** FIX: ä¿®æ­£å›¾ç‰‡è·¯å¾„ ***
                const getTileSymbol = (type) => "â“";
                const hasImage = (type) => !imageLoadErrors.value.has(type);
                const handleImageError = (e) => {
                    const match = e.target.src.match(/tile-(\d+)\.webp/);
                    if (match) imageLoadErrors.value.add(parseInt(match[1]));
                };
                const getTileClasses = (tile) => ({ 'selected': selectedTile.value?.id === tile.id });

                const unlockAudio = () => {
                    if (isAudioUnlocked.value) return;
                    const silentSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABgAZGF0YQAAAAA=');
                    silentSound.play().catch(() => {});
                    isAudioUnlocked.value = true;
                };

                const playSfx = (name) => {
                    if (!sfxEnabled.value || !sfxMap[name]) return;
                    const audio = sfxCache.get(name);
                    if (audio) {
                        audio.currentTime = 0;
                        audio.volume = sfxVolumePercent.value / 100;
                        audio.play().catch(()=>{});
                    }
                };

                const playBgm = (bgm) => {
                    bgmAudio.value?.pause();
                    if (!bgm?.src || !bgmEnabled.value) {
                        bgmPlaying.value = false;
                        return;
                    }
                    const newBgm = new Audio(bgm.src);
                    newBgm.loop = true;
                    newBgm.volume = bgmVolume.value / 100;
                    newBgm.play()
                        .then(() => bgmPlaying.value = true)
                        .catch(() => bgmPlaying.value = false);
                    bgmAudio.value = newBgm;
                    currentBgmId.value = bgm.id;
                };

                const updateBgmVolume = () => { if(bgmAudio.value) bgmAudio.value.volume = bgmVolume.value / 100; localStorage.setItem('bgm_volume', bgmVolume.value); };
                const updateSfxVolume = () => localStorage.setItem('sfx_volume', sfxVolumePercent.value);
                
                const resetGame = () => {
                    score.value = 0; movesUsed.value = 0; gameTime.value = 0; isPaused.value = false;
                    showGameOver.value = false; selectedTile.value = null;
                    if(gameTimer.value) clearInterval(gameTimer.value);
                    gameTimer.value = setInterval(() => { if (!isPaused.value) gameTime.value++; }, 1000);
                    const newBoard = [];
                    for (let r = 0; r < boardSize; r++) {
                        for (let c = 0; c < boardSize; c++) {
                            newBoard.push({ type: 0, id: `${r}-${c}`, row: r, col: c });
                        }
                    }
                    gameBoard.value = newBoard;
                    processMatches();
                };

                const checkMatches=(b)=>{const m=new Set;const cL=l=>{for(let i=0;i<=l.length-3;i++)if(l[i].type&&l[i].type===l[i+1].type&&l[i].type===l[i+2].type)m.add(l[i].id).add(l[i+1].id).add(l[i+2].id)};for(let r=0;r<boardSize;r++)cL(b.slice(r*boardSize,(r+1)*boardSize));for(let c=0;c<boardSize;c++){const o=Array.from({length:boardSize},(_,r)=>b[r*boardSize+c]);cL(o)}return Array.from(m)};
                const processMatches=async()=>{isProcessing.value=!0;let m=checkMatches(gameBoard.value);while(m.length>0){chainCount.value++;score.value+=m.length*10*chainCount.value;if(chainCount.value>1){showMessage.value=!0;message.value=`è¿é”ååº” x${chainCount.value}!`;messageType.value='chain';showChainEffect.value=!0;setTimeout(()=>{showChainEffect.value=!1},1e3)}playSfx('match');m.forEach(i=>{const t=gameBoard.value.find(t=>t.id===i);if(t)t.type=0});await new Promise(r=>setTimeout(r,200));playSfx('fall');for(let c=0;c<boardSize;c++){let e=boardSize-1;for(let r=boardSize-1;r>=0;r--){const t=gameBoard.value[r*boardSize+c];if(t.type!==0){if(e!==r){gameBoard.value[e*boardSize+c].type=t.type;t.type=0}e--}}}await new Promise(r=>setTimeout(r,200));gameBoard.value.forEach(t=>{if(t.type===0)t.type=Math.floor(Math.random()*tileTypes)+1});m=checkMatches(gameBoard.value)}chainCount.value=0;isProcessing.value=!1};
                const handleTileClick=async t=>{if(isProcessing.value)return;if(!selectedTile.value){selectedTile.value=t;playSfx('click');return}const{row:r1,col:c1}=selectedTile.value;const{row:r2,col:c2}=t;if(Math.abs(r1-r2)+Math.abs(c1-c2)===1){isProcessing.value=!0;movesUsed.value++;const i1=r1*boardSize+c1;const i2=r2*boardSize+c2;[gameBoard.value[i1].type,gameBoard.value[i2].type]=[gameBoard.value[i2].type,gameBoard.value[i1].type];await nextTick();const m=checkMatches(gameBoard.value);if(m.length>0){playSfx('swap');selectedTile.value=null;await processMatches()}else{playSfx('error');await new Promise(r=>setTimeout(r,300));[gameBoard.value[i1].type,gameBoard.value[i2].type]=[gameBoard.value[i2].type,gameBoard.value[i1].type];selectedTile.value=t}isProcessing.value=!1}else{playSfx('error');selectedTile.value=t}};

                const startGame = () => { unlockAudio(); playSfx('click'); gameStarted.value = true; resetGame(); playBgm(bgmList.value.find(b => b.id === currentBgmId.value)); };
                const restartGame = () => { playSfx('click'); resetGame(); };
                const togglePause = () => { playSfx('click'); isPaused.value = !isPaused.value; if(isPaused.value) { bgmAudio.value?.pause(); if(gameTimer.value) clearInterval(gameTimer.value); } else { if(bgmEnabled.value) bgmAudio.value?.play(); gameTimer.value = setInterval(() => { gameTime.value++; }, 1000); } };
                const toggleBgm = () => { playSfx('click'); bgmEnabled.value = !bgmEnabled.value; localStorage.setItem('bgm_enabled', bgmEnabled.value); if (bgmEnabled.value) { playBgm(bgmList.value.find(b => b.id === currentBgmId.value)); } else { bgmAudio.value?.pause(); bgmPlaying.value = false; } };
                const toggleSfx = () => { sfxEnabled.value = !sfxEnabled.value; localStorage.setItem('sfx_enabled', sfxEnabled.value); playSfx('click'); };
                const switchBgm = (bgm) => { playSfx('click'); if (currentBgmId.value === bgm.id) return; playBgm(bgm); };
                const openSettings = () => { playSfx('click'); showSettings.value = true; };
                const closeSettings = () => { playSfx('click'); showSettings.value = false; };
                const resetSettings = () => { playSfx('click'); bgmVolume.value = 50; sfxVolumePercent.value = 70; updateBgmVolume(); updateSfxVolume(); };
                
                onMounted(async () => {
                    bgmVolume.value = parseInt(localStorage.getItem('bgm_volume') || '50');
                    sfxVolumePercent.value = parseInt(localStorage.getItem('sfx_volume') || '70');
                    bgmEnabled.value = localStorage.getItem('bgm_enabled') !== 'false';
                    sfxEnabled.value = localStorage.getItem('sfx_enabled') !== 'false';

                    // *** FIX: ä¿®æ­£é¢„åŠ è½½èµ„æºåˆ—è¡¨ä»¥åŒ¹é…çœŸå®è·¯å¾„ ***
                    const assetsToLoad = [];
                    for (const key in sfxMap) { assetsToLoad.push({ type: 'audio', name: key, src: sfxMap[key] }); }
                    for (const bgm of bgmList.value) { assetsToLoad.push({ type: 'audio', name: `bgm_${bgm.id}`, src: bgm.src }); }
                    for (let i = 1; i <= tileTypes; i++) { assetsToLoad.push({ type: 'image', src: getTileImage(i) }); }
                    
                    await Promise.all(assetsToLoad.map(asset => new Promise(resolve => {
                        if (asset.type === 'image') {
                            const img = new Image();
                            img.onload = img.onerror = resolve;
                            img.src = asset.src;
                        } else if (asset.type === 'audio') {
                            const audio = new Audio(asset.src);
                            sfxCache.set(asset.name, audio); // ä½¿ç”¨å”¯ä¸€çš„åå­—ä½œä¸ºkeyç¼“å­˜
                            // å¯¹äºéŸ³é¢‘ï¼Œæˆ‘ä»¬ä¸ç­‰å¾…canplaythroughï¼Œå› ä¸ºè¿™å¯èƒ½å¾ˆæ…¢ã€‚æˆ‘ä»¬åªåˆ›å»ºå®ä¾‹ã€‚
                            resolve();
                        }
                    })));

                    showLoading.value = false;
                });

                onUnmounted(() => { if (gameTimer.value) clearInterval(gameTimer.value); });
                
                return { gameStarted, showGameOver, score, movesUsed, formattedTime, gameBoard, selectedTile, showMessage, message, messageType, showChainEffect, chainCount, bgmPlaying, bgmEnabled, sfxEnabled, bgmList, currentBgmId, showLoading, showSettings, bgmVolume, sfxVolumePercent, particles, isPaused, boardStyle, flatBoard, getTileSymbol, getTileImage, getTileClasses, hasImage, handleImageError, handleOutsideClick: () => selectedTile.value = null, startGame, restartGame, toggleBgm, toggleSfx, switchBgm, updateBgmVolume, updateSfxVolume, resetSettings, openSettings, closeSettings, togglePause, handleTileClick };
            }
        }).mount('#app');
    </script>
</body>
</html>
